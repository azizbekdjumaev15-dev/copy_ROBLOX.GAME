\<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roblox Winter Obby [Normal Gravity]</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', 'Arial', sans-serif; 
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%);
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none; 
        }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            z-index: 10;
        }

        #topbar {
            height: 44px;
            background: rgba(30, 30, 30, 0.8);
            backdrop-filter: blur(10px);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; color: white; font-weight: 700; font-size: 16px;
            pointer-events: auto;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .logo-area { display: flex; align-items: center; gap: 12px; cursor: pointer; }
        .logo-box { 
            background: linear-gradient(135deg, #fff, #ccc); 
            color: #333; 
            width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 4px; 
            font-weight: 900; 
            font-size: 18px;
        }

        /* ROBLOX STYLE MENU */
        #roblox-menu {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 2000;
            pointer-events: auto;
            align-items: center; justify-content: center;
        }
        .menu-content {
            background: #232527;
            width: 320px;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            text-align: center;
            color: white;
            font-family: 'Gotham', sans-serif;
        }
        .menu-btn {
            display: block; width: 100%;
            background: #393b3d;
            color: white;
            border: none;
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            font-size: 18px; font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        .menu-btn:hover { background: #4a4c4e; }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn.primary { background: white; color: #232527; }
        .menu-btn.primary:hover { background: #e0e0e0; }

        /* CENTER HUD */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 8px; height: 8px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }

        #stage-counter {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.5); color: #FFD700;
            padding: 8px 20px; border-radius: 20px; font-weight: bold; font-size: 18px;
            border: 2px solid rgba(255,215,0,0.5);
            text-shadow: 1px 1px 0 #000;
        }

        #chat-container {
            position: absolute; top: 56px; left: 15px;
            width: 300px; height: 200px;
            display: flex; flex-direction: column;
            pointer-events: auto;
            mask-image: linear-gradient(to bottom, transparent, black 10%);
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 10%);
        }
        #chat-messages {
            flex: 1; overflow-y: auto;
            color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-size: 15px; padding-bottom: 8px;
            scrollbar-width: none;
        }
        #chat-input {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 10px; border-radius: 6px; outline: none;
        }

        #tutorial {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.9); font-size: 14px; font-weight: bold;
            text-shadow: 1px 1px 3px black; pointer-events: none;
        }

        #mobile-controls {
            display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; pointer-events: none;
        }
        #stick-container {
            bottom: 40px; left: 40px; width: 140px; height: 140px;
            background: rgba(255,255,255,0.05); border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.15);
            position: absolute; pointer-events: auto;
            backdrop-filter: blur(2px);
        }
        #stick {
            width: 60px; height: 60px; background: rgba(255,255,255,0.3);
            border-radius: 50%; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #jump-btn {
            bottom: 40px; right: 40px; width: 100px; height: 100px;
            background: rgba(255,255,255,0.15); border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            position: absolute; pointer-events: auto;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(2px);
        }
        
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, red 150%);
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease-out;
            z-index: 99;
        }
        
        /* Click to start overlay */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 24px; font-weight: bold;
            pointer-events: auto; cursor: pointer; z-index: 200;
        }
    </style>
</head>
<body>

    <div id="flash"></div>
    <div id="crosshair"></div>
    
    <!-- ROBLOX MENU -->
    <div id="roblox-menu">
        <div class="menu-content">
            <h2 style="margin-top:0; margin-bottom: 20px;">Game Menu</h2>
            <button class="menu-btn primary" onclick="toggleMenu()">Resume</button>
            <button class="menu-btn" onclick="resetCharacter()">Reset Character</button>
            <button class="menu-btn" id="shadow-btn" onclick="toggleShadows()">Shadows: ON</button>
            <div style="margin-top:20px; font-size:12px; color:#aaa;">Winter Obby v2.1 (Gravity Fixed)</div>
        </div>
    </div>

    <div id="start-overlay">
        <div>Click to Play</div>
    </div>

    <div id="ui-layer">
        <div id="topbar">
            <div class="logo-area" onclick="toggleMenu()">
                <div class="logo-box">R</div>
                <div>Winter Parkour ðŸŽ„</div>
            </div>
            <div>ðŸ’Ž 999+</div>
        </div>

        <div id="stage-counter">Stage: 1</div>

        <div id="chat-container">
            <div id="chat-messages">
                <div class="msg" style="color:#FFFF00;">[System]: Welcome! Press ESC for Menu. WASD to Move.</div>
            </div>
            <input type="text" id="chat-input" placeholder="Type here...">
        </div>

        <div id="tutorial">WASD: Move â€¢ SPACE: Jump â€¢ MOUSE: Look</div>

        <div id="mobile-controls">
            <div id="stick-container"><div id="stick"></div></div>
            <div id="jump-btn">
                <svg width="50" height="50" viewBox="0 0 24 24" fill="white"><path d="M12 4l-8 8h6v8h4v-8h6z"/></svg>
            </div>
            <div id="touch-rotate" style="position:absolute; right:0; top:40px; width:50%; height:70%; pointer-events:auto;"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const CONFIG = {
            gravity: 60,  // RESTORED GRAVITY
            jumpForce: 30, // RESTORED JUMP
            speed: 20,    // Normal walk speed
            turnSpeed: 5.0,
            camDist: 14,
            respawnHeight: -20
        };

        let scene, camera, renderer, dirLight;
        let player, playerVelocity = new THREE.Vector3();
        let isGrounded = false;
        let inputs = { w: false, a: false, s: false, d: false, space: false, shift: false, joyX: 0, joyY: 0 };
        let camRotation = { h: 0, v: 0.35 };
        let worldObjects = [], killBricks = [], checkpoints = [];
        let currentStage = 1;
        let spawnPoint = new THREE.Vector3(0, 5, 0);
        let snowSystem, landingParticles = [];
        let menuOpen = false;
        let shadowsEnabled = true;

        // --- TEXTURES ---
        function createTexture(color, type = 'studs') {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,size,size);

            if (type === 'studs') {
                const grad = ctx.createLinearGradient(0, 0, size, size);
                grad.addColorStop(0, "rgba(255,255,255,0.1)");
                grad.addColorStop(1, "rgba(0,0,0,0.1)");
                ctx.fillStyle = grad; ctx.fillRect(0,0,size,size);
                
                const studSize = 32; const gap = 64; const offset = 32;
                for(let x = offset; x < size; x+=gap) {
                    for(let y = offset; y < size; y+=gap) {
                        ctx.fillStyle = "rgba(0,0,0,0.2)";
                        ctx.beginPath(); ctx.arc(x+2,y+2, studSize/2, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = "rgba(255,255,255,0.15)";
                        ctx.beginPath(); ctx.arc(x,y, studSize/2, 0, Math.PI*2); ctx.fill();
                    }
                }
                ctx.strokeStyle = "rgba(255,255,255,0.3)";
                ctx.lineWidth = 8; ctx.strokeRect(0,0,size,size);
            } else if (type === 'face') {
                ctx.fillStyle = "#FFD700"; ctx.fillRect(0,0,size,size);
                ctx.fillStyle = "#1a1a1a";
                ctx.fillRect(70, 90, 24, 24); ctx.fillRect(162, 90, 24, 24); 
                ctx.lineWidth = 10; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.arc(128, 150, 50, 0.2, Math.PI - 0.2); ctx.stroke(); 
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        const MATS = {
            snow: new THREE.MeshStandardMaterial({ map: createTexture('#F0F8FF', 'snow'), roughness: 0.9 }),
            ice: new THREE.MeshPhysicalMaterial({ color: 0x88EEFF, transparent: true, opacity: 0.7, roughness: 0.05 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x5D4037 }),
            leaf: new THREE.MeshStandardMaterial({ color: 0x2E7D32 }),
            lava: new THREE.MeshStandardMaterial({ color: 0xFF3300, emissive: 0xFF0000, emissiveIntensity: 0.8, map: createTexture('#FF0000', 'studs') }),
            check: new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0x333300 }),
            studsGrey: new THREE.MeshStandardMaterial({ map: createTexture('#9E9E9E') }),
            skin: new THREE.MeshStandardMaterial({ color: 0xFFD700 }),
            shirt: new THREE.MeshStandardMaterial({ color: 0x0277BD }),
            pants: new THREE.MeshStandardMaterial({ color: 0x212121 }),
            face: new THREE.MeshBasicMaterial({ map: createTexture(null, 'face') }),
            particle: new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 })
        };

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xE0F7FA, 30, 160);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 500);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(40, 100, 120); 
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -200; 
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200; 
            dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);

            player = createCharacter(true);
            scene.add(player.mesh);

            buildLevel();
            createSnow();
            setupInputs();
            animate();
        }

        function createCharacter() {
            const group = new THREE.Group();
            const createLimb = (w, h, d, mat, x, y, z) => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                return mesh;
            };

            const torso = createLimb(2, 2, 1, MATS.shirt, 0, 3, 0);
            const head = createLimb(1.2, 1.2, 1.2, [MATS.skin, MATS.skin, MATS.skin, MATS.skin, MATS.face, MATS.skin], 0, 4.6, 0);
            
            const legLGroup = new THREE.Group(); legLGroup.position.set(-0.5, 2, 0);
            legLGroup.add(createLimb(1, 2, 1, MATS.pants, 0, -1, 0));

            const legRGroup = new THREE.Group(); legRGroup.position.set(0.5, 2, 0);
            legRGroup.add(createLimb(1, 2, 1, MATS.pants, 0, -1, 0));

            const armLGroup = new THREE.Group(); armLGroup.position.set(-1.5, 4, 0);
            armLGroup.add(createLimb(1, 2, 1, MATS.shirt, 0, -1, 0));

            const armRGroup = new THREE.Group(); armRGroup.position.set(1.5, 4, 0);
            armRGroup.add(createLimb(1, 2, 1, MATS.shirt, 0, -1, 0));

            group.add(torso, head, legLGroup, legRGroup, armLGroup, armRGroup);
            return { mesh: group, parts: { legL: legLGroup, legR: legRGroup, armL: armLGroup, armR: armRGroup, head: head }, animTime: 0 };
        }

        function createPart(x, y, z, w, h, d, mat, type='solid') {
            if (mat.map && type !== 'kill') {
                mat = mat.clone(); mat.map = mat.map.clone();
                mat.map.repeat.set(w/2, d/2); mat.map.needsUpdate = true;
            }
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.userData = { type: type, size: {x:w, y:h, z:d}, box: new THREE.Box3().setFromObject(mesh) };
            
            mesh.userData.box.min.set(x - w/2, y - h/2, z - d/2);
            mesh.userData.box.max.set(x + w/2, y + h/2, z + d/2);

            scene.add(mesh);
            if(type === 'kill') killBricks.push(mesh);
            else if(type === 'checkpoint') {
                mesh.userData.stage = checkpoints.length + 1;
                checkpoints.push(mesh);
                const ptLight = new THREE.PointLight(0xFFFF00, 0.5, 10);
                ptLight.position.set(0, 2, 0); mesh.add(ptLight);
            }
            else worldObjects.push(mesh);
            return mesh;
        }

        function buildLevel() {
            // LOBBY
            createPart(0, -1, 0, 44, 4, 44, MATS.snow);
            
            // DECOR
            createTree(-14, -14); createTree(14, -14); createTree(-14, 14);

            // STAGE 1
            for(let i=1; i<=6; i++) createPart(0, i*1.5, 20 + (i*7), 6, 1, 4, MATS.studsGrey);
            createPart(0, 9, 70, 12, 1, 12, MATS.check, 'checkpoint');

            // STAGE 2
            for(let i=0; i<5; i++) {
                const offset = i % 2 === 0 ? -4 : 4;
                createPart(offset, 9, 85 + (i*10), 4, 0.5, 4, MATS.ice);
            }
            createPart(0, 9, 140, 12, 1, 12, MATS.check, 'checkpoint');

            // STAGE 3
            createPart(0, 9, 160, 16, 1, 30, MATS.studsGrey);
            for(let i=0; i<4; i++) createPart(0, 9.6, 152 + (i*8), 16, 0.3, 3, MATS.lava, 'kill');

            // STAGE 4
            for(let i=0; i<12; i++) createPart(0, 9 + (i*2), 180 + (i*5), 7, 1, 3, MATS.snow);

            // WIN
            createPart(0, 33, 245, 24, 2, 24, MATS.snow);
            const chest = new THREE.Mesh(new THREE.BoxGeometry(3,2,2), new THREE.MeshStandardMaterial({color:0xFFD700}));
            chest.position.set(5, 35, 245); scene.add(chest);
        }

        function createTree(x, z) {
            const g = new THREE.Group();
            const t = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 2.5, 7), MATS.wood); t.position.y=1.25; g.add(t);
            for(let i=0; i<3; i++) {
                const l = new THREE.Mesh(new THREE.ConeGeometry(2.2-i*0.5, 1.8, 8), MATS.leaf); l.position.y=2.5+i; g.add(l);
                const s = new THREE.Mesh(new THREE.ConeGeometry((2.2-i*0.5)*0.85, 0.6, 8), MATS.snow); s.position.y=2.9+i; g.add(s);
            }
            g.position.set(x, 1, z); scene.add(g);
        }

        function createSnow() {
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(3000 * 3);
            for(let i=0; i<9000; i+=3) {
                pos[i] = (Math.random()-0.5) * 300;
                pos[i+1] = Math.random() * 150;
                pos[i+2] = (Math.random()-0.5) * 300;
            }
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            snowSystem = new THREE.Points(geom, new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true }));
            scene.add(snowSystem);
        }

        function animateCharacter(charObj, state, dt) {
            charObj.animTime += dt * 8;
            const t = charObj.animTime; const parts = charObj.parts;
            if (state === 'idle') {
                parts.armL.rotation.x = Math.sin(t*0.5)*0.1; parts.armR.rotation.x = Math.sin(t*0.5+Math.PI)*0.1;
                parts.legL.rotation.x = 0; parts.legR.rotation.x = 0;
            } else if (state === 'walk') {
                parts.legL.rotation.x = Math.sin(t); parts.legR.rotation.x = Math.sin(t+Math.PI);
                parts.armL.rotation.x = Math.sin(t+Math.PI); parts.armR.rotation.x = Math.sin(t);
            } else if (state === 'jump') {
                parts.armL.rotation.x = Math.PI; parts.armR.rotation.x = Math.PI;
                parts.legL.rotation.x = -0.5; parts.legR.rotation.x = 0.5;
            }
        }

        function updatePhysics(dt) {
            if (menuOpen) return; // Freeze when menu open

            const camDir = new THREE.Vector3(Math.sin(camRotation.h), 0, Math.cos(camRotation.h));
            const camRight = new THREE.Vector3(Math.sin(camRotation.h - Math.PI/2), 0, Math.cos(camRotation.h - Math.PI/2));

            const moveDir = new THREE.Vector3();
            if(inputs.w) moveDir.sub(camDir);
            if(inputs.s) moveDir.add(camDir);
            if(inputs.a) moveDir.add(camRight); 
            if(inputs.d) moveDir.sub(camRight); 

            if(inputs.joyX || inputs.joyY) {
                moveDir.addScaledVector(camRight, -inputs.joyX);
                moveDir.addScaledVector(camDir, inputs.joyY);
            }

            if(moveDir.lengthSq() > 0) moveDir.normalize();

            // PHYSICS: WALKING & GRAVITY
            playerVelocity.x = moveDir.x * CONFIG.speed;
            playerVelocity.z = moveDir.z * CONFIG.speed;
            playerVelocity.y -= CONFIG.gravity * dt;
            playerVelocity.y = Math.max(playerVelocity.y, -50); // Terminal velocity

            const nextPos = player.mesh.position.clone().addScaledVector(playerVelocity, dt);
            
            // COLLISIONS
            const pSize = 0.8; 
            const pMinX = nextPos.x - pSize; const pMaxX = nextPos.x + pSize;
            const pMinZ = nextPos.z - pSize; const pMaxZ = nextPos.z + pSize;

            let groundY = -999;
            let onGround = false;
            
            // Check World Objects
            for(let obj of worldObjects) {
                const b = obj.userData.box;
                if (pMaxX > b.min.x && pMinX < b.max.x && pMaxZ > b.min.z && pMinZ < b.max.z) {
                    const top = b.max.y;
                    if (player.mesh.position.y >= top - 2.5) { 
                        if (top > groundY) groundY = top;
                    }
                }
            }

            // Check Checkpoints
            for(let cp of checkpoints) {
                const b = cp.userData.box;
                 if (pMaxX > b.min.x && pMinX < b.max.x && pMaxZ > b.min.z && pMinZ < b.max.z) {
                    const top = b.max.y;
                    if (player.mesh.position.y >= top - 2.5 && top > groundY) groundY = top;

                    if(cp.userData.stage > currentStage) {
                        currentStage = cp.userData.stage;
                        document.getElementById('stage-counter').innerText = `Stage: ${currentStage}`;
                        spawnPoint.copy(cp.position).add(new THREE.Vector3(0,5,0));
                        cp.material.emissive.setHex(0x00FF00);
                    }
                }
            }

            // Check Kill Bricks
            const playerBox = new THREE.Box3();
            playerBox.min.set(nextPos.x - pSize, nextPos.y, nextPos.z - pSize);
            playerBox.max.set(nextPos.x + pSize, nextPos.y + 5, nextPos.z + pSize);

            for(let kb of killBricks) {
                if(playerBox.intersectsBox(kb.userData.box)) {
                    die(); return;
                }
            }

            // Landing logic
            if(nextPos.y <= groundY) {
                nextPos.y = groundY;
                playerVelocity.y = 0;
                if(!isGrounded) {
                    for(let i=0; i<5; i++) {
                        const m = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), MATS.particle);
                        m.position.copy(nextPos).add(new THREE.Vector3((Math.random()-.5)*2, 0.5, (Math.random()-.5)*2));
                        scene.add(m);
                        landingParticles.push({mesh:m, vel: new THREE.Vector3((Math.random()-.5), Math.random(), (Math.random()-.5)), age:0});
                    }
                }
                onGround = true;
            }

            isGrounded = onGround;
            if(isGrounded && inputs.space) {
                playerVelocity.y = CONFIG.jumpForce;
                isGrounded = false;
            }

            player.mesh.position.copy(nextPos);

            if(moveDir.lengthSq() > 0.1) {
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                let rotDiff = targetRot - player.mesh.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                player.mesh.rotation.y += rotDiff * CONFIG.turnSpeed * dt;
                animateCharacter(player, isGrounded ? 'walk' : 'jump', dt);
            } else {
                animateCharacter(player, isGrounded ? 'idle' : 'jump', dt);
            }

            if(player.mesh.position.y < CONFIG.respawnHeight) die();
        }

        function die() {
            player.mesh.position.copy(spawnPoint);
            playerVelocity.set(0,0,0);
            document.getElementById('flash').style.opacity = 0.6;
            setTimeout(() => document.getElementById('flash').style.opacity = 0, 200);
            camRotation.h = 0;
            // Removed cam reset to keep orientation
        }

        function updateCamera() {
            const headPos = player.mesh.position.clone().add(new THREE.Vector3(0, 3.5, 0));
            
            // UNLOCKED 360 VERTICAL LOOK (Clamped slightly to avoid flip glitch)
            camRotation.v = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, camRotation.v));

            const hDist = CONFIG.camDist * Math.cos(camRotation.v);
            const vDist = CONFIG.camDist * Math.sin(camRotation.v);
            
            // Standard orbit camera logic
            const offset = new THREE.Vector3(Math.sin(camRotation.h) * hDist, vDist, Math.cos(camRotation.h) * hDist);
            camera.position.copy(headPos).add(offset);
            camera.lookAt(headPos);
        }

        // --- MENU FUNCTIONS ---
        window.toggleMenu = function() {
            menuOpen = !menuOpen;
            const menu = document.getElementById('roblox-menu');
            const overlay = document.getElementById('start-overlay');
            
            if (menuOpen) {
                menu.style.display = 'flex';
                document.exitPointerLock();
            } else {
                menu.style.display = 'none';
                if (!overlay.style.display || overlay.style.display === 'none') {
                    document.body.requestPointerLock();
                }
            }
        };

        window.resetCharacter = function() {
            die();
            toggleMenu();
        };

        window.toggleShadows = function() {
            shadowsEnabled = !shadowsEnabled;
            dirLight.castShadow = shadowsEnabled;
            document.getElementById('shadow-btn').innerText = shadowsEnabled ? "Shadows: ON" : "Shadows: OFF";
        };

        function setupInputs() {
            const keys = { KeyW: 'w', KeyS: 's', KeyA: 'a', KeyD: 'd', Space: 'space', ShiftLeft: 'shift', ShiftRight: 'shift' };
            document.addEventListener('keydown', e => {
                if (e.code === 'Escape') {
                   // ESC handled natively for exiting lock, but we hook into lock change below
                }
                if(keys[e.code] && document.activeElement.tagName !== 'INPUT') inputs[keys[e.code]] = true;
                if(e.code === 'Slash') { e.preventDefault(); document.getElementById('chat-input').focus(); }
            });
            document.addEventListener('keyup', e => { if(keys[e.code]) inputs[keys[e.code]] = false; });

            const overlay = document.getElementById('start-overlay');
            
            overlay.addEventListener('click', () => {
                document.body.requestPointerLock();
                overlay.style.display = 'none';
            });

            // Listen for Pointer Lock exit to show menu or pause state logic
            document.addEventListener('pointerlockchange', () => {
                if(!document.pointerLockElement) {
                    if (!menuOpen) {
                        // If we just lost focus but menu wasn't explicitly opened, show menu
                        toggleMenu(); 
                    }
                }
            });

            document.addEventListener('mousemove', e => {
                if (document.pointerLockElement && !menuOpen) {
                    camRotation.h -= e.movementX * 0.003; 
                    camRotation.v += e.movementY * 0.003; 
                }
            });

            if('ontouchstart' in window) {
                document.getElementById('mobile-controls').style.display = 'block';
                document.getElementById('tutorial').innerHTML = "Touch Left to Move â€¢ Swipe Right to Look";
                overlay.style.display = 'none'; 

                // Add mobile menu button
                const mobMenu = document.createElement('div');
                mobMenu.innerText = "Îž";
                mobMenu.style.cssText = "position:absolute; top:10px; right:10px; width:40px; height:40px; background:rgba(0,0,0,0.5); color:white; display:flex; align-items:center; justify-content:center; border-radius:8px; font-size:24px; pointer-events:auto; z-index:1001;";
                mobMenu.onclick = toggleMenu;
                document.getElementById('ui-layer').appendChild(mobMenu);

                const stick = document.getElementById('stick');
                let stickStart = {x:0, y:0};
                const stickContainer = document.getElementById('stick-container');
                stickContainer.addEventListener('touchstart', e => {
                    e.preventDefault(); 
                    stickStart = {x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY};
                }, { passive: false });
                
                stickContainer.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const dx = e.changedTouches[0].clientX - stickStart.x;
                    const dy = e.changedTouches[0].clientY - stickStart.y;
                    const dist = Math.min(50, Math.sqrt(dx*dx+dy*dy));
                    const angle = Math.atan2(dy, dx);
                    stick.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                    inputs.joyX = Math.cos(angle)*dist / 50; inputs.joyY = Math.sin(angle)*dist / 50;
                }, { passive: false });
                
                stickContainer.addEventListener('touchend', () => {
                    stick.style.transform = `translate(-50%, -50%)`; inputs.joyX = 0; inputs.joyY = 0;
                }, { passive: false });

                let lastX=0, lastY=0;
                const touchRotate = document.getElementById('touch-rotate');
                touchRotate.addEventListener('touchstart', e => {
                    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
                }, { passive: false });
                
                touchRotate.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - lastX; const dy = e.touches[0].clientY - lastY;
                    camRotation.h -= dx * 0.008; camRotation.v += dy * 0.008; 
                    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
                }, { passive: false });

                const jumpBtn = document.getElementById('jump-btn');
                jumpBtn.addEventListener('touchstart', e=>{e.preventDefault(); inputs.space=true;}, { passive: false });
                jumpBtn.addEventListener('touchend', e=>{e.preventDefault(); inputs.space=false;}, { passive: false });
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            updatePhysics(dt);
            updateCamera();
            
            for(let i=landingParticles.length-1; i>=0; i--) {
                const p = landingParticles[i]; p.age += dt;
                p.mesh.position.addScaledVector(p.vel, dt); p.mesh.scale.multiplyScalar(0.9);
                if(p.age > 1.0) { scene.remove(p.mesh); landingParticles.splice(i, 1); }
            }

            if(snowSystem) {
                const pos = snowSystem.geometry.attributes.position.array;
                for(let i=1; i<pos.length; i+=3) {
                    pos[i] -= dt * 15; 
                    if(pos[i] < -20) pos[i] = 130; 
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.position.x = player.mesh.position.x * 0.8; 
                snowSystem.position.z = player.mesh.position.z * 0.8;
            }

            renderer.render(scene, camera);
        }
        window.onload = init;
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>